
extern "C"
{
  function()
}


//grenerate so
gcc main.cpp -fPIC -shared -o libmain.so

step1:
(javac xxx.java->generate xxx execute file
java xxx)
先在A.java文件中loadLibrary，设置native接口

step2:
然后javac成A.class文件

step3:
然后再对A进行javah，生成新的jni的.h文件  javah A
注意：如果报找不到相应的class，看下CLASSPATH是否指向此处，否则会报这错误；
重设CLASSPATH：CLASSPATH=path;export CLASSPATH

javac想指定将.java的class生成到某个目录下，用-d参数
javah想指定load 哪儿的class 用-classpath path，记得最后加要load的class名
javah -d ../native_layer/jni_include/ -classpath ./bin/ AgoraJavaRecording

step4:
然后编写.c文件包含这个.h文件


step5:
编译.c文件
 -I 包含jni.h和jni_md.h的位置
gcc -o libmain.so -shared -fPIC -I /usr/lib/jvm/java-9-openjdk-amd64/include/ helloworld.c -lc -I /usr/lib/jvm/java-9-openjdk-amd64/include/linux/

step6:
java xxx
 
end!

-I 包含jni.h和jni_md.h的位置
gcc -o libmain.so -shared -fPIC -I /usr/lib/jvm/java-9-openjdk-amd64/include/ helloworld.c -lc -I /usr/lib/jvm/java-9-openjdk-amd64/include/linux/
//gcc -o libforhelloworld.so -shared -fPIC -I (PATH TO jni.h header) HelloWorld.c -lc

